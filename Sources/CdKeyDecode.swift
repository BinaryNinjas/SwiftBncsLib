class CdKeyDecode {

    static let KeyTable: [UInt8] = [
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x00, 0xFF, 0x01, 0xFF, 0x02, 0x03, 0x04, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0x0F, 0x10, 0xFF,
        0x11, 0xFF, 0x12, 0xFF, 0x13, 0xFF, 0x14, 0x15, 0x16, 0x17, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0x0F, 0x10, 0xFF,
        0x11, 0xFF, 0x12, 0xFF, 0x13, 0xFF, 0x14, 0x15, 0x16, 0x17, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    ]

    static let TranslateTable: [UInt8] = [
        0x09, 0x04, 0x07, 0x0F, 0x0D, 0x0A, 0x03, 0x0B, 0x01, 0x02, 0x0C, 0x08, 0x06, 0x0E, 0x05, 0x00,
        0x09, 0x0B, 0x05, 0x04, 0x08, 0x0F, 0x01, 0x0E, 0x07, 0x00, 0x03, 0x02, 0x0A, 0x06, 0x0D, 0x0C,
        0x0C, 0x0E, 0x01, 0x04, 0x09, 0x0F, 0x0A, 0x0B, 0x0D, 0x06, 0x00, 0x08, 0x07, 0x02, 0x05, 0x03,
        0x0B, 0x02, 0x05, 0x0E, 0x0D, 0x03, 0x09, 0x00, 0x01, 0x0F, 0x07, 0x0C, 0x0A, 0x06, 0x04, 0x08,
        0x06, 0x02, 0x04, 0x05, 0x0B, 0x08, 0x0C, 0x0E, 0x0D, 0x0F, 0x07, 0x01, 0x0A, 0x00, 0x03, 0x09,
        0x05, 0x04, 0x0E, 0x0C, 0x07, 0x06, 0x0D, 0x0A, 0x0F, 0x02, 0x09, 0x01, 0x00, 0x0B, 0x08, 0x03,
        0x0C, 0x07, 0x08, 0x0F, 0x0B, 0x00, 0x05, 0x09, 0x0D, 0x0A, 0x06, 0x0E, 0x02, 0x04, 0x03, 0x01,
        0x03, 0x0A, 0x0E, 0x08, 0x01, 0x0B, 0x05, 0x04, 0x02, 0x0F, 0x0D, 0x0C, 0x06, 0x07, 0x09, 0x00,
        0x0C, 0x0D, 0x01, 0x0F, 0x08, 0x0E, 0x05, 0x0B, 0x03, 0x0A, 0x09, 0x00, 0x07, 0x02, 0x04, 0x06,
        0x0D, 0x0A, 0x07, 0x0E, 0x01, 0x06, 0x0B, 0x08, 0x0F, 0x0C, 0x05, 0x02, 0x03, 0x00, 0x04, 0x09,
        0x03, 0x0E, 0x07, 0x05, 0x0B, 0x0F, 0x08, 0x0C, 0x01, 0x0A, 0x04, 0x0D, 0x00, 0x06, 0x09, 0x02,
        0x0B, 0x06, 0x09, 0x04, 0x01, 0x08, 0x0A, 0x0D, 0x07, 0x0E, 0x00, 0x0C, 0x0F, 0x02, 0x03, 0x05,
        0x0C, 0x07, 0x08, 0x0D, 0x03, 0x0B, 0x00, 0x0E, 0x06, 0x0F, 0x09, 0x04, 0x0A, 0x01, 0x05, 0x02,
        0x0C, 0x06, 0x0D, 0x09, 0x0B, 0x00, 0x01, 0x02, 0x0F, 0x07, 0x03, 0x04, 0x0A, 0x0E, 0x08, 0x05,
        0x03, 0x06, 0x01, 0x05, 0x0B, 0x0C, 0x08, 0x00, 0x0F, 0x0E, 0x09, 0x04, 0x07, 0x0A, 0x0D, 0x02,
        0x0A, 0x07, 0x0B, 0x0F, 0x02, 0x08, 0x00, 0x0D, 0x0E, 0x0C, 0x01, 0x06, 0x09, 0x03, 0x05, 0x04,
        0x0A, 0x0B, 0x0D, 0x04, 0x03, 0x08, 0x05, 0x09, 0x01, 0x00, 0x0F, 0x0C, 0x07, 0x0E, 0x02, 0x06,
        0x0B, 0x04, 0x0D, 0x0F, 0x01, 0x06, 0x03, 0x0E, 0x07, 0x0A, 0x0C, 0x08, 0x09, 0x02, 0x05, 0x00,
        0x09, 0x06, 0x07, 0x00, 0x01, 0x0A, 0x0D, 0x02, 0x03, 0x0E, 0x0F, 0x0C, 0x05, 0x0B, 0x04, 0x08,
        0x0D, 0x0E, 0x05, 0x06, 0x01, 0x09, 0x08, 0x0C, 0x02, 0x0F, 0x03, 0x07, 0x0B, 0x04, 0x00, 0x0A,
        0x09, 0x0F, 0x04, 0x00, 0x01, 0x06, 0x0A, 0x0E, 0x02, 0x03, 0x07, 0x0D, 0x05, 0x0B, 0x08, 0x0C,
        0x03, 0x0E, 0x01, 0x0A, 0x02, 0x0C, 0x08, 0x04, 0x0B, 0x07, 0x0D, 0x00, 0x0F, 0x06, 0x09, 0x05,
        0x07, 0x02, 0x0C, 0x06, 0x0A, 0x08, 0x0B, 0x00, 0x0F, 0x04, 0x03, 0x0E, 0x09, 0x01, 0x0D, 0x05,
        0x0C, 0x04, 0x05, 0x09, 0x0A, 0x02, 0x08, 0x0D, 0x03, 0x0F, 0x01, 0x0E, 0x06, 0x07, 0x0B, 0x00,
        0x0A, 0x08, 0x0E, 0x0D, 0x09, 0x0F, 0x03, 0x00, 0x04, 0x06, 0x01, 0x0C, 0x07, 0x0B, 0x02, 0x05,
        0x03, 0x0C, 0x04, 0x0A, 0x02, 0x0F, 0x0D, 0x0E, 0x07, 0x00, 0x05, 0x08, 0x01, 0x06, 0x0B, 0x09,
        0x0A, 0x0C, 0x01, 0x00, 0x09, 0x0E, 0x0D, 0x0B, 0x03, 0x07, 0x0F, 0x08, 0x05, 0x02, 0x04, 0x06,
        0x0E, 0x0A, 0x01, 0x08, 0x07, 0x06, 0x05, 0x0C, 0x02, 0x0F, 0x00, 0x0D, 0x03, 0x0B, 0x04, 0x09,
        0x03, 0x08, 0x0E, 0x00, 0x07, 0x09, 0x0F, 0x0C, 0x01, 0x06, 0x0D, 0x02, 0x05, 0x0A, 0x0B, 0x04,
        0x03, 0x0A, 0x0C, 0x04, 0x0D, 0x0B, 0x09, 0x0E, 0x0F, 0x06, 0x01, 0x07, 0x02, 0x00, 0x05, 0x08
    ]

    static let W3_KEYLEN = 26
    static let W3_BUFLEN = W3_KEYLEN * 2

    var productValue: UInt32 = 0
    var value1: UInt32 = 0
    var value2: [UInt8] = []

    init(cdkey: String) {
        var table = [UInt8](repeating: 0, count: CdKeyDecode.W3_BUFLEN)
        var values: [UInt32] = [0, 0, 0, 0]

        tableLookup(key: cdkey.uppercased(), buf: &table)

        for i in (0..<CdKeyDecode.W3_BUFLEN).reversed() {
            Mult(bufB: &values, decodedByte: table[i])
        }

        decodeKeyTablePass1(keyTable: &values)
        decodeKeyTablePass2(keyTable: &values)

        productValue = values[0] >> 0x0a
        value1 = ((values[0] & 0x03FF) << 0x10) | (values[1] >> 0x10)

        value2 = [
            values[1] & 0xFF,
            (values[1] >> 8) & 0xFF,
            (values[2]) & 0xFF,
            (values[2] >> 8) & 0xFF,
            (values[2] >> 16) & 0xFF,
            (values[2] >> 24) & 0xFF,
            (values[3]) & 0xFF,
            (values[3] >> 8) & 0xFF,
            (values[3] >> 16) & 0xFF,
            (values[3] >> 24) & 0xFF
        ].map { UInt8($0) }

    }

    func tableLookup(key: String, buf: inout [UInt8]) {
        var a = 0
        var b = 0x21

        for i in 0..<CdKeyDecode.W3_KEYLEN {
            a = (b + 0x07B5) % CdKeyDecode.W3_BUFLEN
            b = (a + 0x07B5) % CdKeyDecode.W3_BUFLEN

            let decode = CdKeyDecode.KeyTable[Int(key.utf8CString[i])]
            buf[a] = decode / 5
            buf[b] = decode % 5
        }
    }

    func Mult(bufB: inout [UInt32], decodedByte: UInt8) {

        var bufA = bufB
        var copy_decodedByte = decodedByte

        for position in (0..<4).reversed() {
            let edxeax = Int64(bufA[position]) * 5

            bufB[position] = UInt32(copy_decodedByte) + UInt32(truncatingBitPattern: edxeax)
            copy_decodedByte = UInt8(truncatingBitPattern: edxeax >> 32)
        }
    }

    func decodeKeyTablePass1(keyTable: inout [UInt32]) {
        var ebx = 0 as UInt32
        var ecx = 0 as UInt32
        var esi = 0 as UInt32
        var ebp = 0 as UInt32
        var var_C = 0 as UInt32
        var var_4 = 0 as UInt32
        var var_8 = 29 as UInt32 // 29 * 16 = 464.. loop counter of some sort

        for i: UInt32 in stride(from: 464, through: 0, by: -16) {

            esi = (var_8 & 7) << 2
            var_4 = var_8 >> 3
            var_C = (keyTable[3 - Int(var_4)] & (0x0F << esi)) >> esi

            if (i < 464) {
                for j in stride(from: 29, to: var_8, by: -1) {
                ecx = (j & 7) << 2
                ebp = (keyTable[0x03 - (Int(j) >> 3)] & (0x0F << ecx)) >> ecx
                var_C = UInt32(CdKeyDecode.TranslateTable[Int(ebp ^ UInt32(CdKeyDecode.TranslateTable[Int(var_C + i)]) + i)])
                }
            }

            if var_8 > 0 {
                var_8 -= 1 // decrement loop counter
                for j: UInt32 in stride(from: var_8, through: 0, by: -1) {
                    ecx = (j & 7) << 2;
                    ebp = keyTable[Int(0x3 - (j >> 3))]
                    ebp &= (0xF << ecx)
                    ebp = ebp >> ecx
                    var_C = UInt32(CdKeyDecode.TranslateTable[Int(ebp ^ UInt32(CdKeyDecode.TranslateTable[Int(var_C + i)]) + i)])
                }
            }

            let index = 3 - Int(var_4)
            ebx = (UInt32(CdKeyDecode.TranslateTable[Int(var_C + i)]) & 0x0F) << esi;

            print(esi)
            keyTable[index] = ebx | ~(0x0F << esi) & keyTable[index]
            print(keyTable[index])
        }
    }

    func decodeKeyTablePass2(keyTable: inout [UInt32]) {
        var ecx = 0 as UInt32
        var esi = 0 as UInt32
        var ebp = 0 as UInt32
        var edx = 0 as UInt32
        var eax = 0 as UInt32

        var copy: [UInt8] = [
            keyTable[0]       & 0xFF, keyTable[0] >>  8 & 0xFF,
            keyTable[0] >> 16 & 0xFF, keyTable[0] >> 24 & 0xFF,
            keyTable[1]       & 0xFF, keyTable[1] >>  8 & 0xFF,
            keyTable[1] >> 16 & 0xFF, keyTable[1] >> 24 & 0xFF,
            keyTable[2]       & 0xFF, keyTable[2] >>  8 & 0xFF,
            keyTable[2] >> 16 & 0xFF, keyTable[2] >> 24 & 0xFF,
            keyTable[3]       & 0xFF, keyTable[3] >>  8 & 0xFF,
            keyTable[3] >> 16 & 0xFF, keyTable[3] >> 24 & 0xFF
        ].map { UInt8($0) }

        for edi: UInt32 in 0..<120 {

            eax = edi & 0x1F;
            ecx = esi & 0x1F;
            edx = 3 - (edi >> 5);

            let location = 12 - ((esi >> 5) << 2);
            ebp = UInt32(copy[Int(location)])
                | (UInt32(copy[Int(location + 1)]) << 8)
                | (UInt32(copy[Int(location + 2)]) << 16)
                | (UInt32(copy[Int(location + 3)]) << 24)

            ebp = (ebp & (1 << ecx)) >> ecx
            keyTable[Int(edx)] = ((ebp & 1) << eax) | (~(1 << eax) & keyTable[Int(edx)])

            esi += 0x0B;
            if (esi >= 120) {
                esi -= 120;
            }
        }
    }

}
